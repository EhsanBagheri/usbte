<!DOCTYPE html>
<html>
<!-- USBTE -->
<!-- See: https://wicg.github.io/webusb/ -->
<!-- See: https://wicg.github.io/serial/ -->

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
<title>USBTE</title>
    <style>
        pre { white-space: pre-wrap; word-wrap: break-word; }
    </style>
</head>

<body onload='Body()'>

<h1>USBTE -- Web USB terminal emulator</h1>

<!-- For bulk endpoint access, CpuStick vendorId/productId 0x0403/0xa660 with cdc/acm class/subclass 02/02 is replaced with FF/00 -->

Filter to USB:
VID: <input id='vendorId' name='vendorId' size='4'/>
PID: <input id='productId' name='productId' size='4'/>

<p>
If your device exposes a virtual serial port, select:
<button type='button' onclick="Comm();">COMM</button>

<p>Otherwise, for bulk endpoint access, set:
<!-- bulk endpoint from device -->
epin: <input id='epin' name='epin' size='1' value='2'/>
<!-- bulk endpoint to device -->
epout: <input id='epout' name='epout' size='1' value='3'/>
and select:
<button type='button' onclick="Usb();">USB</button>

<p>
Ctrl-C and Ctrl-D flow thru the command line when in focus.

<h2>results</h2>
<pre id='results'></pre>

<h2> command line</h2>
<input id='command' name='command' size='80' disabled='true'/>
<button type='button' onclick="Paste();">Paste</button>

<p>
<a href=https://github.com/rtestardi/usbte target=_blank>https://github.com/rtestardi/usbte</a>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href=https://github.com/rtestardi/StickOS target=_blank>https://github.com/rtestardi/StickOS</a>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href=https://rtestardi.github.io/StickOS/ target=_blank>Old StickOS Website</a>

<script>

var comm;
var reader;
var writer;
var usb;
var enc = new TextEncoder();
var dec = new TextDecoder();

function Body()
{
    document.body.addEventListener("keydown", function(event) {
        if (event.keyCode === 67 && event.ctrlKey && document.activeElement === document.getElementById("command")) {
            // ctrl-c in command line -- stop the program
            event.preventDefault();
            event.stopPropagation();
            Enter("\003");
        }
        if (event.keyCode === 68 && event.ctrlKey && document.activeElement === document.getElementById("command")) {
            // ctrl-d in command line -- log out of remote
            event.preventDefault();
            event.stopPropagation();
            Enter("\004");
        }
        if (event.keyCode === 13) {
            // enter -- run the command line
            event.preventDefault();
            Enter(document.getElementById("command").value + "\r");
        }
    })
}

async function Usb()
{
    var filter = {};
    if (document.getElementById("vendorId").value != "") {
        filter["vendorId"] = document.getElementById("vendorId").value;
        if (document.getElementById("productId").value != "") {
            filter["productId"] = document.getElementById("productId").value;
        }
    }

    try {
        usb = await navigator.usb.requestDevice({ filters: [filter] });
        await usb.open();
        await usb.selectConfiguration(1);
        await usb.claimInterface(1);
        setTimeout(Poll, 100);
        document.getElementById("command").disabled = false;
        document.getElementById("command").focus();
    } catch(err) {
        document.getElementById("results").innerHTML += err.message.replace(/</g,'&lt;').replace(/>/g,'&gt;') + "\r";
    }
}

async function Comm()
{
    var filter = {};
    if (document.getElementById("vendorId").value != "") {
        filter["usbVendorId"] = document.getElementById("vendorId").value;
        if (document.getElementById("productId").value != "") {
            filter["usbProductId"] = document.getElementById("productId").value;
        }
    }

    if ('serial' in navigator) {
        try {
            comm = await navigator.serial.requestPort("usbVendorId" in filter ? { filters: [filter] } : {});
            await comm.open({ baudRate: 115200, bufferSize: 64 });
            reader = comm.readable.getReader();
            writer = comm.writable.getWriter();
            setTimeout(Poll, 100);
            document.getElementById("command").disabled = false;
            document.getElementById("command").focus();
        } catch(err) {
            document.getElementById("results").innerHTML += err.message.replace(/</g,'&lt;').replace(/>/g,'&gt;') + "\r";
        }
    } else {
        document.getElementById("results").innerHTML +=
`The Web serial API needs to be enabled in your browser thru:
   - edge://flags/#enable-experimental-web-platform-features
   - chrome://flags/#enable-experimental-web-platform-features
   - opera://flags/#enable-experimental-web-platform-features
`;
    }
}

async function Poll()
{
    var result;
    var str;
    if (usb) {
        result = await usb.transferIn(document.getElementById("epin").value, 64);
        str = dec.decode(result.data.buffer);
    } else {
        result = await reader.read();
        str = dec.decode(result.value);
    }
    if (str.match(/\033[[]2J/)) {
        // clear screen on cls  XXX -- misses fragmented escape
        document.getElementById("results").innerHTML = "";
        str = "";
    }
    document.getElementById("results").innerHTML += str.replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'');
    document.getElementById("command").scrollIntoView();
    setTimeout(Poll, 10);
}

async function Enter(str)
{
    if (usb) {
        await usb.transferOut(document.getElementById("epout").value, enc.encode(str).buffer);
    } else {
        await writer.write(enc.encode(str).buffer);
    }
    document.getElementById("command").value = "";
    document.getElementById("command").focus();
}

async function Paste()
{
    text = await navigator.clipboard.readText();
    Enter(text + "\r");
}

</script>
</body>
</html>
