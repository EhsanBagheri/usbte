
<!DOCTYPE html>
<html>
<!-- SCOPE -->
<!-- See: https://wicg.github.io/webusb/ -->
<!-- See: https://wicg.github.io/serial/ -->

<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
<title>SCOPE</title>
    <style>
pre { white-space: pre-wrap; word-wrap: break-word; }
a { text-decoration: none; }
#results { line-height: 1.2; }
#copyright { font-size:65%; padding: 0px; }
* { overflow-wrap: anywhere; word-wrap: anywhere; }
button { overflow-wrap: normal; word-wrap: normal; }
html,button,input,select { font: 36px Arial, Helvetica, sans-serif; padding: 15px 10px 15px 10px; margin: 15px 0px 15px 0px; }
@media(min-width:80em){ html,button,input { font: 24px Arial, Helvetica, sans-serif; padding: 10px; margin: 10px 0px 10px 0px; } }
@supports(-webkit-touch-callout:none) { button,input { -webkit-appearance: none; border-radius: 2px; } }
body,html { margin: 0px; }
#canvas { outline: red 1px solid; padding: 4px; }
    </style>
</head>

<body onload='Body()'>

<h1>Web SCOPE</h1>

<div id="config">
Select:
<button type='button' onclick="if (navigator.appVersion.indexOf('Win') != -1) { Comm(); } else { Usb(); }">Config</button>
</div>

sample usec:
<select id="usec">
<option>1</option>
<option>3</option>
<option selected>10</option>
<option>30</option>
<option>100</option>
<option>300</option>
<option>1000</option>
</select>

--

trigger:
<select id="trigger">
<option selected value="~">auto</option>
<option value="">level</option>
<option value="+">rise</option>
<option value="-">fall</option>
</select>

--

<button onclick="analogV = 0; analogY = 255;">zero</button>

--

slew %:
<select id="slew">
<option value="0">0</option>
<option selected value="51">5</option>
<option value="102">10</option>
<option value="204">20</option>
<option value="307">30</option>
<option value="409">40</option>
</select>

--

<button onclick="for (var b = 0; b < 6; b++) { document.getElementById('b'+b).selectedIndex = 0; }">clear</button>

--

b0:
<select id="b0">
<option selected value="">-</option>
<option value="0">0</option>
<option value="1">1</option>
</select>

b1:
<select id="b1">
<option selected value="">-</option>
<option value="0">0</option>
<option value="1">1</option>
</select>

b2:
<select id="b2">
<option selected value="">-</option>
<option value="0">0</option>
<option value="1">1</option>
</select>

b3:
<select id="b3">
<option selected value="">-</option>
<option value="0">0</option>
<option value="1">1</option>
</select>

b4:
<select id="b4">
<option selected value="">-</option>
<option value="0">0</option>
<option value="1">1</option>
</select>

b5:
<select id="b5">
<option selected value="">-</option>
<option value="0">0</option>
<option value="1">1</option>
</select>

--

delay usec:
<input type="text" id="delay" value="0" size="2"></input>

--

volts:
<select id="volts">
<option value="3.3">3.3</option>
</select>

<br>

<canvas id="canvas" width="2044" height="456"></canvas>

<button id="pause" onclick="Pause();">pause</button>
<pre id='status'></pre>


<pre id='command'></pre>
<pre id='results'></pre>

<p id='copyright'>
<a href=https://github.com/rtestardi/usbte target=_blank>github.com/rtestardi/usbte</a>
&nbsp;&nbsp;&nbsp;
<a href=https://github.com/rtestardi/StickOS target=_blank>github.com/rtestardi/StickOS</a>
&nbsp;&nbsp;&nbsp;
<a href=https://rtestardi.github.io/StickOS target=_blank>rtestardi.github.io/StickOS</a>

<script>
'use strict';

var usb;
var comm;
var reader;
var writer;
var enc = new TextEncoder();
var dec = new TextDecoder();
var canvas;
var ctx;

var discard;
var discarded;
var string;

var digital = false;

var analogV = 0;  // 511;
var analogY = 255;  // 128;

var down = false;
var drag = false;
var dragX;
var dragY;
var dragT;

function Pause()
{
    if (document.getElementById('pause').innerHTML == "pause") {
        down = true;
        document.getElementById('pause').innerHTML = "resume";
    } else {
        down = false;
        document.getElementById('pause').innerHTML = "pause";
    }
}

function Status(dx, dy)
{
    var status = "position: " + dragX/2*parseInt(document.getElementById("usec").value) + " usec";
    if (dragY < 256) {
        status +=  ", " + (dragY*parseInt(document.getElementById("volts").value)/256).toFixed(2) + " volts"
    }
    if (dx || dy) {
        status += "; delta: " + dx/2*parseInt(document.getElementById("usec").value) + " usec";
        if (dragY < 256) {
            status += ", " + (dy*parseInt(document.getElementById("volts").value)/256).toFixed(2) + " volts";
        }
    }
    return status;
}

// the user loaded the webpage; set up keyboard listeners
function Body()
{
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    canvas.addEventListener('mousedown', function(e) {
        down = true;
        drag = false;
        dragX = e.offsetX;
        dragY = e.offsetY;
        dragT = e.timeStamp;
        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');
        ctx.strokeRect(dragX-2, dragY-2, 4, 4);
        document.getElementById("status").innerHTML = Status(0, 0);
    })
    canvas.addEventListener('mousemove', function(e) {
        if (down) {
            drag = true;
            var dx = Math.abs(dragX - e.offsetX);
            var dy = Math.abs(dragY - Math.min(e.offsetY, 255));
            document.getElementById("status").innerHTML = Status(dx, dy);
        }
    })
    canvas.addEventListener('mouseup', function(e) {
        down = false;
        drag = false;
        if (e.timeStamp - dragT < 500 && e.offsetY < 256) {
            analogY = e.offsetY;
            analogV = Math.floor((255-analogY)*1024/256);
        }
    })
}

// the user wants to connect to a USB device's bulk endpoints directly
async function Usb()
{
    var filter = {};
    filter["vendorId"] = 0x0403;
    filter["productId"] = 0xA660;

    try {
        usb = await navigator.usb.requestDevice({ filters: [filter] });
        await usb.open();
        await usb.selectConfiguration(1);
        await usb.claimInterface(1);

        document.getElementById("results").innerHTML = "";
        document.getElementById("config").hidden = true;

        discard = 1;
        setTimeout(Receive, 2);

        Send(String.fromCharCode(3));
        Send("echo off\n");
        Send("prompt off\n");

        discarded = false;
        setTimeout(Discard, 200);
    } catch(err) {
        document.getElementById("results").innerHTML = err.message.replace(/</g,'&lt;').replace(/>/g,'&gt;') + "\r";
    }
}

// the user wants to connect to an emulated COM port
async function Comm()
{
    var filter = {};
    filter["usbVendorId"] = 0x0403;
    filter["usbProductId"] = 0xA660;

    if ('serial' in navigator) {
        try {
            comm = await navigator.serial.requestPort({ filters: [filter] });
            await comm.open({ baudRate: 115200, bufferSize: 64 });
            reader = comm.readable.getReader();
            writer = comm.writable.getWriter();

            document.getElementById("results").innerHTML = "";
            document.getElementById("config").hidden = true;

            discard = 1;
            setTimeout(Receive, 2);

            Send(String.fromCharCode(3));
            Send("echo off\n");
            Send("prompt off\n");

            discarded = false;
            setTimeout(Discard, 200);
        } catch(err) {
            document.getElementById("results").innerHTML = err.message.replace(/</g,'&lt;').replace(/>/g,'&gt;') + "\r";
        }
    } else {
        document.getElementById("results").innerHTML =
`The Web serial API needs to be enabled in your browser thru:
   - <a href=edge://flags/#enable-experimental-web-platform-features>edge://flags/#enable-experimental-web-platform-features</a>
   - <a href=chrome://flags/#enable-experimental-web-platform-features>chrome://flags/#enable-experimental-web-platform-features</a>
   - <a href=opera://flags/#enable-experimental-web-platform-features>opera://flags/#enable-experimental-web-platform-features</a>
`;
    }
}

async function Discard()
{
    if (discarded) {
        discarded = false;
        setTimeout(Discard, 200);
    } else {
        setTimeout(Scope, 200);
    }
}

async function Scope()
{
    discard = 0;
    string = "";

    digital = false;
    var number1 = document.getElementById("usec").value;
    var number2;
    var number3;
    var number4;

    for (var b = 0; b < 6; b++) {
        if (document.getElementById("b"+b).value != "") {
            digital = true;
        }
    }

    if (digital) {
        var mask = 0;
        var bits = 0;
        for (var b = 0; b < 6; b++) {
            if (document.getElementById("b"+b).value != "") {
                mask |= 1<<b;
            }
            if (document.getElementById("b"+b).value == "1") {
                bits |= 1<<b;
            }
        }
        number2 = document.getElementById("trigger").value + "0x" + bits.toString(16);
        number3 = "0x" + mask.toString(16);
    } else {
        number2 = document.getElementById("trigger").value + analogV;
        number3 = document.getElementById("slew").value;
    }

    number4 = document.getElementById("delay").value;

    var command = "scope " + number1 + " " + number2 + " " + number3 + " " + number4;

    document.getElementById("command").innerHTML = command;
    Send(command + "\n");
}

async function Display()  // result is in string
{
    var delay = 200;

    if (! down) {
        var lines = string.split(/\r?\n/);

        ctx.clearRect(0, 0, 2044, 512);

        ctx.fillText("3.3V", 2008, 8);
        ctx.fillText("0V", 2008, 255);

        for (var i = 0; i <= 10; i++) {
            if (Math.floor(i/5)*5 == i) {
                ctx.setLineDash([6, 10])
            } else {
                ctx.setLineDash([2, 10])
            }
            ctx.beginPath();
            ctx.moveTo(200*i, 0);
            ctx.lineTo(200*i, 255);
            ctx.stroke();
            ctx.setLineDash([])

            ctx.fillText("" + parseInt(document.getElementById("usec").value)*i/10 + "ms", i*200+2, 126);
        }

        if (! digital) {
            ctx.setLineDash([10, 4])
            ctx.strokeStyle = '#00BF00';
            ctx.beginPath();
            ctx.moveTo(0, analogY);
            ctx.lineTo(2000, analogY);
            ctx.stroke();

            ctx.beginPath();
            if (document.getElementById("trigger").value == '+' && document.getElementById("slew").value != 0 && analogY+document.getElementById("slew").value/4 < 256) {
                ctx.moveTo(0, analogY+document.getElementById("slew").value/4);
                ctx.setLineDash([4, 10]);
                ctx.lineTo(2000, analogY+document.getElementById("slew").value/4);
            }
            if (document.getElementById("trigger").value == '-' && document.getElementById("slew").value != 0 && analogY-document.getElementById("slew").value/4 >= 0) {
                ctx.moveTo(0, analogY-document.getElementById("slew").value/4);
                ctx.setLineDash([4, 10]);
                ctx.lineTo(2000, analogY-document.getElementById("slew").value/4);
            }
            ctx.stroke();
            ctx.strokeStyle = '#000000';
            ctx.setLineDash([])
        }

        if (lines.length < 10) {
            document.getElementById("command").innerHTML += " no trigger";
        } else {
            var path;
            path = new Path2D();  // analog
            path.moveTo(0, 255);

            var paths = [];
            var lastBit = [];
            for (var b = 0; b < 6; b++) {
                paths[b] = new Path2D();  // digital

                paths[b].moveTo(0, 305+b*30);
                lastBit[b] = false;
            }

            for (var i = 0; i < 1000 && i < lines.length; i++) {
                var words = lines[i].split(/ /);

                var adc = parseInt(words[0])
                path.lineTo(i*2, 255-adc/4);

                for (b = 0; b < 6; b++) {
                    var bit = (parseInt(words[1]) & (1 << b)) != 0;
                    if (bit == lastBit[b]) {
                        paths[b].lineTo(i*2, 305+b*30 - (bit?20:0));
                    } else {
                        paths[b].lineTo(i*2, 305+b*30 - (lastBit[b]?20:0));
                        paths[b].lineTo(i*2, 305+b*30 - (bit?20:0));
                    }
                    lastBit[b] = bit;
                }
            }

            path.moveTo(2000, 255);
            ctx.stroke(path);

            for (b = 0; b < 6; b++) {
                if (lastBit[b]) {
                    paths[b].lineTo(i*2, 305+b*30 - (lastBit[b]?20:0));
                    paths[b].lineTo(i*2, 305+b*30 - (false?20:0));
                } else {
                    paths[b].lineTo(i*2, 305+b*30 - (false?20:0));
                }

                if (document.getElementById("b"+b).value != "") {
                    ctx.strokeStyle = '#00BF00';
                }
                ctx.stroke(paths[b]);
                if (document.getElementById("b"+b).value != "") {
                    ctx.strokeStyle = '#000000';
                }

                ctx.fillText("b"+b, 2008, 305-2+b*30);
            }

            document.getElementById("command").innerHTML = " ";
            delay=100;
        }
    }

    setTimeout(Scope, delay);
}

// receive a string from the device
async function Receive()
{
    var str;
    var result;

    if (usb) {
        result = await usb.transferIn(2, 64);
        str = dec.decode(result.data.buffer);
    } else {
        result = await reader.read();
        str = dec.decode(result.value);
    }
    if (! discard) {
        string += str.replace(/</g,'&lt;').replace(/>/g,'&gt;');
        if (string.match(/done/)) {
            Display()
        }
    } else {
        discarded = true;
    }
    setTimeout(Receive, 2);
}

// send a string to the device
async function Send(str)
{
    if (usb) {
        await usb.transferOut(3, enc.encode(str).buffer);
    } else {
        await writer.write(enc.encode(str).buffer);
    }
}

</script>
</body>
</html>
